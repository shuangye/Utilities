#!/usr/bin/env python
# -*- coding:utf8 -*-

import sys
import os
import codecs
import string
import re
import datetime


def work(ddl_path, header_path):    
    if (None == ddl_path or None == header_path):
        print("Invalid argument")
        return -1

    try:
        file_in = open(ddl_path, mode = "r", encoding="utf8")
    except OSError as e:
        print("Failed to open file " + ddl_path + "for parsing: " + str(e.errno) + e.strerror)    
        return -1

    try:
        file_out = open(header_path, mode = "w", encoding="utf8")
    except OSError as e:
        print("Failed to open file for writing result: " + str(e.errno) + e.strerror)    

    type_maps = { 
        "CHAR"            : "Char", 
        "VARCHAR"         : "Char",        
        "DATE"            : "Char",
        "DATETIME"        : "Char",
        "TINYINT"         : "Int8",
        "SMALLINT"        : "Int16",
        "INT"             : "Int32",
        "FLOAT"           : "Float32"
    }
    date_str_len = "12"  # YYYYMMDD
    datetime_str_len = "16" # YYYYMMDDHHMMSS
    
    is_in_table_context = False
    is_at_table_start = False    
    table_name = ""
    field_name = ""
    field_type = ""
    field_size = ""
    field_comment = ""
    table_begin_pattern = r'\s*CREATE\s+TABLE\s+(\w+)\s*'                          # matches 'CREATE TABLE table_name'
    table_end_pattern = r'\s*\)\s*;\s*'                                            # matches ');'
    field_pattern = r'([a-zA-Z_]+\w*)\s+([a-zA-Z]+)\s*\(?(\d*)\)?.*,\s*--\s*(.*)'  # matches sth. like 'reluuid CHAR(32) NOT NULL, -- comments' or 'sync TINYINT, -- comments'
    # field_pattern = re.compile(field_pattern, re.IGNORECASE)
    # match = re.search(field_pattern, line, flags = re.IGNORECASE)
    
    # file header
    file_base_name = os.path.basename(header_path)
    header_guard_macro = "__" + file_base_name.replace('.', '_').upper() + "__"
    print("#pragma once", file = file_out, end = '\n');
    print("#ifndef {guard}".format(guard = header_guard_macro), file = file_out, end = '\n');
    print("#define {guard}".format(guard = header_guard_macro), file = file_out, end = '\n');
    print("", file = file_out, end = '\n')
    print("/* Created by Papillon. {now}. */".format(now = datetime.datetime.now().strftime("%c")), file = file_out, end = '\n')
    print("/* WARNING: DO NOT EDIT THIS FILE. IT IS GENERATED BY A SCRIPT AUTOMATICALLY. */", file = file_out, end = '\n')
    print("", file = file_out, end = '\n')  # 2 empty lines
    print("", file = file_out, end = '\n')
    
    # file content
    for line in file_in:
        line = line.strip()
        if (len(line) == 0):
            continue
        if (line.startswith("--")):  # skip comments
            continue
        
        # determine if table definition ends
        match = re.search(table_end_pattern, line, re.IGNORECASE)
        if (None != match):
            is_in_table_context = False
            print("}} DBM_{table_name};".format(table_name = table_name), file = file_out, end = '\n')
            print("", file = file_out, end = '\n')  # 2 empty lines
            print("", file = file_out, end = '\n')
            continue
        
        # determine if table definition starts
        match = re.search(table_begin_pattern, line, re.IGNORECASE)
        if (None != match):
            is_at_table_start = True
            is_in_table_context = True
            
        if (is_at_table_start):
            table_name = match.group(1)
            print("typedef struct DBM_{table_name}".format(table_name = table_name), file = file_out, end = '\n')
            print("{", file = file_out, end = '\n');
            is_at_table_start = False
            continue
        
        # determine if within table definition
        if (is_in_table_context):
            match = re.search(field_pattern, line, re.IGNORECASE)
            if (None == match):
                continue
            field_name = match.group(1)
            field_type = match.group(2)
            field_comment = match.group(4)
            if (field_type in type_maps.keys()):
                c_field_type = type_maps[field_type]
                field_size = ""
                if (c_field_type == "Char" and len(match.group(3)) > 0):
                    field_size = "[" + match.group(3) + "]"                
                if (field_type.upper() == "DATE"):
                    field_size = "[" + date_str_len + "]"
                elif (field_type.upper() == "DATETIME"):
                    field_size = "[" + datetime_str_len + "]"
                print("".ljust(4) 
                      + "{c_field_type}".format(c_field_type = c_field_type).ljust(20)
                      + "{field_name}{field_size};".format(field_name = field_name, field_size = field_size,).ljust(30)
                      + "/* {field_comment} */".format(field_comment = field_comment),
                      file = file_out, end = '\n')                
            else:
                print("Unrecognized SQL data type " + field_type)
                continue            

    # file footer
    print("#endif  /* {guard} */".format(guard = header_guard_macro), file = file_out, end = '\n');    
    file_in.close()
    file_out.close()

    
    
if (len(sys.argv) < 3):
    print("usage: {0} ddl_path header_path".format(sys.argv[0]))
    sys.exit(-1)
else:
    work(sys.argv[1], sys.argv[2])
